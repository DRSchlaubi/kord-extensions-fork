{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Kord Extensions is an addon for the excellent Kord library . It intends to provide a framework for larger bot projects, with easy-to-use commands, rich argument parsing and event handling, wrapped up into individual extension classes. The approach taken here is relatively different from a lot of Kotlin libraries, many of which prefer to provide a DSL for quickly prototyping or implementing a small application. Instead, Discord.py (the Discord library for Python) is a primary source of inspiration for our fairly object-oriented design, especially where it comes to its extensions (which are known as cogs in Discord.py). Despite this, we still strive to provide an idiomatic API that makes full use of Kotlin's niceties. Why not kordx.commands? Kord has released their own command framework, kordx.commands . It's a competent library, but it takes some very different approaches to solving the same problems Kord Extensions does. Most notably, it requires the use of kapt and makes use of an annotation-based autowire system for getting things registered. In contrast, Kord Extensions provides a less magical approach that is more closely tied to object-oriented programming, and may be more suitable for embedding into other applications. At the end of the day, though, the choice is yours - both approaches have pros and cons, and it's worth checking both out to see what you like better! Usage To make use of Kord Extensions, update your build script to add https://maven.kotlindiscord.com/repository/maven-snapshots/ as a Maven repository, and use com.kotlindiscord.kord.extensions:kord-extneions:VERSION as the Maven coordinate. For a list of available versions, take a look at Nexus . We do not currently have a strict semantic versioning system in place. We'll explore this later if needed, but right now we recommend pinning to the latest snapshot version number. For more specific directions for individual build systems, take a look at the Getting Started guide .","title":"Home"},{"location":"#home","text":"Kord Extensions is an addon for the excellent Kord library . It intends to provide a framework for larger bot projects, with easy-to-use commands, rich argument parsing and event handling, wrapped up into individual extension classes. The approach taken here is relatively different from a lot of Kotlin libraries, many of which prefer to provide a DSL for quickly prototyping or implementing a small application. Instead, Discord.py (the Discord library for Python) is a primary source of inspiration for our fairly object-oriented design, especially where it comes to its extensions (which are known as cogs in Discord.py). Despite this, we still strive to provide an idiomatic API that makes full use of Kotlin's niceties. Why not kordx.commands? Kord has released their own command framework, kordx.commands . It's a competent library, but it takes some very different approaches to solving the same problems Kord Extensions does. Most notably, it requires the use of kapt and makes use of an annotation-based autowire system for getting things registered. In contrast, Kord Extensions provides a less magical approach that is more closely tied to object-oriented programming, and may be more suitable for embedding into other applications. At the end of the day, though, the choice is yours - both approaches have pros and cons, and it's worth checking both out to see what you like better!","title":"Home"},{"location":"#usage","text":"To make use of Kord Extensions, update your build script to add https://maven.kotlindiscord.com/repository/maven-snapshots/ as a Maven repository, and use com.kotlindiscord.kord.extensions:kord-extneions:VERSION as the Maven coordinate. For a list of available versions, take a look at Nexus . We do not currently have a strict semantic versioning system in place. We'll explore this later if needed, but right now we recommend pinning to the latest snapshot version number. For more specific directions for individual build systems, take a look at the Getting Started guide .","title":"Usage"},{"location":"getting-started/","text":"Getting Started We recommend making use of Gradle for your build scripts, with a kx_version entry in your gradle.properties . Please note that Kord Extensions requires Kotlin 1.4 or later . build.gradle.kts 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = uri ( \"https://maven.kotlindiscord.com/repository/maven-public/\" ) } } dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions:$kx_version\" ) } build.gradle 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = \"https://maven.kotlindiscord.com/repository/maven-snapshots/\" } } dependencies { implementation \"com.kotlindiscord.kord.extensions:kord-extensions:$kx_version\" } pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <project> <repositories> <repository> <id> kotlin-discord </id> <name> Kotlin Discord </name> <url> https://maven.kotlindiscord.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.kotlindiscord.kord.extensions </groupId> <artifactId> kord-extensions </artifactId> <version> VERSION </version> </dependency> </dependencies> </project> A Basic Extension Kord Extensions is a relatively complex library, but the API it provides is fairly simple. In this example, we'll create an extension containing a command, and we'll create a bot with that extension installed on it. Initial Files Create an extension by extending the Extension class. TestExtension.kt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class TestExtension ( bot : ExtensibleBot ) : Extension ( bot ) { override val name = \"test\" // The registered name for our extension class TestArgs : Arguments () { // The arguments our command takes // A single required string argument val string by string ( \"string\" ) // Multiple boolean arguments, requiring at least one val bools by booleanList ( \"bools\" ) } // This will be called when the extension gets set up override suspend fun setup () { command { // Define a command // The name of the command name = \"test\" // A description for the help command to show description = \"Test command, please ignore\" // Generate a command signature from the arguments class signature ( :: TestArgs ) action { // This block will be executed when the command is run with ( parse ( :: TestArgs )) { // Parse the command arguments message . channel . createEmbed { // Kord: Create an embed title = \"Test response\" description = \"Test description\" field { name = \"String\" value = string // Required string is never null } field { name = \"Bools (${bools.size})\" value = bools . joinToString ( \", \" ) { \"`$it`\" } } } } } } } } Finally, create your main function, creating a bot, adding your extension to it and starting it up. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun main () { // New instance of the bot provided by Kord Extensions val bot = ExtensibleBot ( // Discord bot token for logging in System . getenv ( \"TOKEN\" ), // Prefix required before all command names \"!\" ) // Add the extension class, the bot will instantiate it bot . addExtension ( TestExtension :: class ) // Start the bot, blocking the current coroutine bot . start () } Test it out Set the TOKEN environment variable to a Discord bot token, and run your application. Wait for it to connect, and send !help test in a DM or any channel the bot has access to. Now, try running the command! For example, !test String yes no false will give you:","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"We recommend making use of Gradle for your build scripts, with a kx_version entry in your gradle.properties . Please note that Kord Extensions requires Kotlin 1.4 or later . build.gradle.kts 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = uri ( \"https://maven.kotlindiscord.com/repository/maven-public/\" ) } } dependencies { implementation ( \"com.kotlindiscord.kord.extensions:kord-extensions:$kx_version\" ) } build.gradle 1 2 3 4 5 6 7 8 9 10 repositories { maven { name = \"Kotlin Discord\" url = \"https://maven.kotlindiscord.com/repository/maven-snapshots/\" } } dependencies { implementation \"com.kotlindiscord.kord.extensions:kord-extensions:$kx_version\" } pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <project> <repositories> <repository> <id> kotlin-discord </id> <name> Kotlin Discord </name> <url> https://maven.kotlindiscord.com/repository/maven-public/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> com.kotlindiscord.kord.extensions </groupId> <artifactId> kord-extensions </artifactId> <version> VERSION </version> </dependency> </dependencies> </project>","title":"Getting Started"},{"location":"getting-started/#a-basic-extension","text":"Kord Extensions is a relatively complex library, but the API it provides is fairly simple. In this example, we'll create an extension containing a command, and we'll create a bot with that extension installed on it.","title":"A Basic Extension"},{"location":"getting-started/#initial-files","text":"Create an extension by extending the Extension class.","title":"Initial Files"},{"location":"getting-started/#testextensionkt","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class TestExtension ( bot : ExtensibleBot ) : Extension ( bot ) { override val name = \"test\" // The registered name for our extension class TestArgs : Arguments () { // The arguments our command takes // A single required string argument val string by string ( \"string\" ) // Multiple boolean arguments, requiring at least one val bools by booleanList ( \"bools\" ) } // This will be called when the extension gets set up override suspend fun setup () { command { // Define a command // The name of the command name = \"test\" // A description for the help command to show description = \"Test command, please ignore\" // Generate a command signature from the arguments class signature ( :: TestArgs ) action { // This block will be executed when the command is run with ( parse ( :: TestArgs )) { // Parse the command arguments message . channel . createEmbed { // Kord: Create an embed title = \"Test response\" description = \"Test description\" field { name = \"String\" value = string // Required string is never null } field { name = \"Bools (${bools.size})\" value = bools . joinToString ( \", \" ) { \"`$it`\" } } } } } } } } Finally, create your main function, creating a bot, adding your extension to it and starting it up. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun main () { // New instance of the bot provided by Kord Extensions val bot = ExtensibleBot ( // Discord bot token for logging in System . getenv ( \"TOKEN\" ), // Prefix required before all command names \"!\" ) // Add the extension class, the bot will instantiate it bot . addExtension ( TestExtension :: class ) // Start the bot, blocking the current coroutine bot . start () }","title":"TestExtension.kt"},{"location":"getting-started/#test-it-out","text":"Set the TOKEN environment variable to a Discord bot token, and run your application. Wait for it to connect, and send !help test in a DM or any channel the bot has access to. Now, try running the command! For example, !test String yes no false will give you:","title":"Test it out"},{"location":"utils/","text":"Utilities To make your life easier, Kord Extensions contains a number of utilities. These utilities have been categorized by type, to make things easier to find. Why not PR these to Kord? At its core, Kord is a protocol library and caching implementation. It's designed to follow Discord's API spec as close as it can and, while it does provide many niceties, not every utility makes sense to include directly within Kord. If you feel like that's not the way things should be, please have a chat with the Kord team - we're always working with them and we'll happily share whatever utilities they feel should be upstream! Channels Function Description ensureWebhook Ensures that a webhook with the given parameters exists in a channel, and returns it for use Deltas Kord itself doesn't contain any real way to compare two events or objects, so Kord Extensions includes some deltas you can use to find the difference between certain objects. UserDelta for comparing two base User objects MemberDelta for comparing two guild Member objects In both cases, you should use the static from function to create a delta object. Because Discord's API is very inconsistent with how data is structured, bear in mind the following tips: If a property is null , then there was no difference between the two objects - aside from nickname and boosting , which will be an absent Java Optional if there was no change These classes were written long before Kord introduced its own optionals - they'll need to be revised to match Kord 0.7.x and its APIs at some point Kord Property Description Kord.users Quick access to a Flow containing all Kord User objects that are in the cache Function Description Kord.waitFor Simple function for waiting for a specific Kord event, with a timeout Members Function Description Member.hasRole Checks whether a guild member has the given role Member.getTopRole Returns the guild member's top role, or null if they don't have a role Messages Property Description MessageData.authorId Quick access to the message author's ID MessageData.authorIsBot Quick access to check whether the message author is a bot Function Description Message.deleteIgnoringNotFound Convenience function to delete a message and ignore any errors if the message no longer exists Message.deleteWithDelay Convenience function to delete a message after a delay, which does not block the current coroutine or thread Message.getUrl Convenience function to construct the URL for a message Message.parse Parses message content into a list using an Apache Commons StringTokenizer , which supports quotes for individual values with spaces Message.requireChannel Function that ensures a message was sent within a given channel (with some options), responding with an error if not Message.requireGuildChannel Function that ensures a message was not sent privately (with some options), responding with an error if it was Message.respond Convenience function to respond to a user's message, with the option to use either Discord's replies feature or just a mention Misc Function Description String.parseBoolean Parses a String into a Boolean based on its starting character - 0 , n or f for false or 1 , y or t for true , otherwise null String.splitOn Splits a string into a Pair containing the characters matching the predicate up until its first failure, and the rest of the string String.startsWithVowel Checks whether the string starts with a vowel runSuspended Convenience function to run a block of code in a coroutine dispatcher, defaulting to Dispatchers.IO - useful for otherwise blocking calls Optional This utility only concerns Java's own Optional s, not Kord's Optional s Function Description Optional.getOrNull Returns the Optional 's value if it's present, or null if it isn't Optional.isAbsent Checks whether the Optional is not present Scheduler The Scheduler class is a rudimentary approach to scheduling Job s within a given coroutine scope, with the option to cancel the Job early if required. The following instance functions are available for this: Function Description cancelAll Immediately cancel the execution of all scheduled jobs cancelJob Given a job's UUID, cancel its execution finishAll Immediately execute the callbacks of all scheduled jobs finishJob Given a job's UUID, immediately execute its callback getJob Given a job's UUID, return the Job object - or null if the UUID doesn't match anything schedule Schedule a job - either returning a generated UUID, or using a provided one Time Function Description Duration.toSeconds For a Time4J Duration , return the total number of seconds it contains Duration.toHuman For a Java Time Duration , return a human-readable string in the form a days, b hours, c minutes and d seconds (omitting zero-values) Users Property Description User.createdAt Quick access to a user's creation time, taken from their Snowflake Function Description User.dm Send a private message to a user, returning a Message object if successfull or null if the user has their private messages disabled topRole Retrieve a user's top role, given a guild's Snowflake","title":"Utilities"},{"location":"utils/#utilities","text":"To make your life easier, Kord Extensions contains a number of utilities. These utilities have been categorized by type, to make things easier to find. Why not PR these to Kord? At its core, Kord is a protocol library and caching implementation. It's designed to follow Discord's API spec as close as it can and, while it does provide many niceties, not every utility makes sense to include directly within Kord. If you feel like that's not the way things should be, please have a chat with the Kord team - we're always working with them and we'll happily share whatever utilities they feel should be upstream!","title":"Utilities"},{"location":"utils/#channels","text":"Function Description ensureWebhook Ensures that a webhook with the given parameters exists in a channel, and returns it for use","title":"Channels"},{"location":"utils/#deltas","text":"Kord itself doesn't contain any real way to compare two events or objects, so Kord Extensions includes some deltas you can use to find the difference between certain objects. UserDelta for comparing two base User objects MemberDelta for comparing two guild Member objects In both cases, you should use the static from function to create a delta object. Because Discord's API is very inconsistent with how data is structured, bear in mind the following tips: If a property is null , then there was no difference between the two objects - aside from nickname and boosting , which will be an absent Java Optional if there was no change These classes were written long before Kord introduced its own optionals - they'll need to be revised to match Kord 0.7.x and its APIs at some point","title":"Deltas"},{"location":"utils/#kord","text":"Property Description Kord.users Quick access to a Flow containing all Kord User objects that are in the cache Function Description Kord.waitFor Simple function for waiting for a specific Kord event, with a timeout","title":"Kord"},{"location":"utils/#members","text":"Function Description Member.hasRole Checks whether a guild member has the given role Member.getTopRole Returns the guild member's top role, or null if they don't have a role","title":"Members"},{"location":"utils/#messages","text":"Property Description MessageData.authorId Quick access to the message author's ID MessageData.authorIsBot Quick access to check whether the message author is a bot Function Description Message.deleteIgnoringNotFound Convenience function to delete a message and ignore any errors if the message no longer exists Message.deleteWithDelay Convenience function to delete a message after a delay, which does not block the current coroutine or thread Message.getUrl Convenience function to construct the URL for a message Message.parse Parses message content into a list using an Apache Commons StringTokenizer , which supports quotes for individual values with spaces Message.requireChannel Function that ensures a message was sent within a given channel (with some options), responding with an error if not Message.requireGuildChannel Function that ensures a message was not sent privately (with some options), responding with an error if it was Message.respond Convenience function to respond to a user's message, with the option to use either Discord's replies feature or just a mention","title":"Messages"},{"location":"utils/#misc","text":"Function Description String.parseBoolean Parses a String into a Boolean based on its starting character - 0 , n or f for false or 1 , y or t for true , otherwise null String.splitOn Splits a string into a Pair containing the characters matching the predicate up until its first failure, and the rest of the string String.startsWithVowel Checks whether the string starts with a vowel runSuspended Convenience function to run a block of code in a coroutine dispatcher, defaulting to Dispatchers.IO - useful for otherwise blocking calls","title":"Misc"},{"location":"utils/#optional","text":"This utility only concerns Java's own Optional s, not Kord's Optional s Function Description Optional.getOrNull Returns the Optional 's value if it's present, or null if it isn't Optional.isAbsent Checks whether the Optional is not present","title":"Optional"},{"location":"utils/#scheduler","text":"The Scheduler class is a rudimentary approach to scheduling Job s within a given coroutine scope, with the option to cancel the Job early if required. The following instance functions are available for this: Function Description cancelAll Immediately cancel the execution of all scheduled jobs cancelJob Given a job's UUID, cancel its execution finishAll Immediately execute the callbacks of all scheduled jobs finishJob Given a job's UUID, immediately execute its callback getJob Given a job's UUID, return the Job object - or null if the UUID doesn't match anything schedule Schedule a job - either returning a generated UUID, or using a provided one","title":"Scheduler"},{"location":"utils/#time","text":"Function Description Duration.toSeconds For a Time4J Duration , return the total number of seconds it contains Duration.toHuman For a Java Time Duration , return a human-readable string in the form a days, b hours, c minutes and d seconds (omitting zero-values)","title":"Time"},{"location":"utils/#users","text":"Property Description User.createdAt Quick access to a user's creation time, taken from their Snowflake Function Description User.dm Send a private message to a user, returning a Message object if successfull or null if the user has their private messages disabled topRole Retrieve a user's top role, given a guild's Snowflake","title":"Users"},{"location":"concepts/bot/","text":"The Bot Object The bot object is the core of your application. All bots that make use of Kord Extensions must make use of the ExtensibleBot class - usually by creating an instance of it and using it as a jumping-off point. Extending the ExtensibleBot class Generally speaking, it's best to use ExtensibleBot directly and approach us if there's some functionality missing you need, but the option to extend it is always there if you have a very niche use-case. If you're not sure whether your use-case is appropriate for a wider public release, please open an issue - we're always happy to have a chat with you! Creating a Bot The first thing you'll want to do is create an instance of ExtensibleBot. A basic setup looks something like this: 1 2 3 4 val token = \"...\" // Get your bot token val prefix = \"!\" // Prefix required before all command invocations val bot = ExtensibleBot ( token , prefix ) // Create the bot The ExtensibleBot constructor takes a number of arguments. We recommend supplying them using keyword arguments, just in case the order needs to be changed later on. Invoke command on mention Currently a bug exists that prevents the functionality referenced by invokeCommandOnMention from working. We'll look into this as soon as we can - but if you need this functionality for your bots, contact us and we'll prioritise it. Name Type Default Description token String The Discord bot token to login with prefix String The prefix required before all command invocations addHelpExtension Boolean true Whether to add the bundled help extension automatically addSentryExtension Boolean true Whether to add the bundled Sentry integration extension automatically invokeCommandOnMention Boolean true Whether commands may also be invoked by mentioning the bot messageCacheSize Int 10_000 How many messages to keep in the messages cache by default commandThreads Int CPUs * 2 How many threads to use for the command execution threadpool guildsToFill List <Snowflake> [ ] A list of guilds to request all members for during the connection phase. This requires the GuildMembers intent, specified in the start function fillPresences Boolean? null Whether to request presences for the above members ( true / false , or null for the default). This requires the GuildPresences intent, specified in the start function Adding extensions When you've written some Extensions , you'll need to add them to the bot before they can be used. This can be done at any point, but we recommend doing it before you connect to Discord, as many extensions rely on Discord's ReadyEvent to set up. 1 2 bot . addExtension ( LogsExtension :: class ) bot . addExtension ( TestExtension :: class ) Starting up When you're all set up, and you've registered all your extensions, you can call the start function to create a Kord instance and connect to Discord. 1 bot . start () This function takes a number of optional arguments which - just like before - you should supply using keyword arguments where possible. Not Implemented: Sharding Sharding is currently not supported. We haven't had a chance to look at it yet, as none of the developers are currently working on bots that require sharding. If you need sharding, please contact us and we can work out the details. Name Type Description presenceBuilder PresenceBuilder.() Provide a lambda here to set the bot's initial presence, defaulting to online with no activity intents IntentsBuilder.()? Provide a lambda here to provide a set of intents that your bot does and does not require Properties A few properties are available to you, for getting access to Kord or querying some of the bot's state. Further properties There are other non-private properties available, but they aren't necessarily something you'll need to touch. Most of the properties are open to facilitate niche use-cases that require extending the ExtensibleBot class. Name Type Description kord Kord Current connected Kord instance, if the bot has been started commands List <Command> All currently-registered command objects eventHandlers List <EventHandler> All currently-registered event handler objects extensions Map <String, Extension> All currently-loaded extension objects Functions A number of functions are available to you as well. Further functions There are other non-private functions available, but they aren't necessarily something you'll need to touch. Most of the functions are open to facilitate niche use-cases that require extending the ExtensibleBot class, but a handful are inline for the sake of avoiding function call overhead. Name Description start Connect to Discord, blocking the coroutine scope send Send an event to all event handlers - either a Kord Event or an ExtensionEvent object addExtension Instantiate and load an extension loadExtension Set up a previously-unloaded extension unloadExtension Tear down a previously-loaded extension","title":"The Bot Object"},{"location":"concepts/bot/#the-bot-object","text":"The bot object is the core of your application. All bots that make use of Kord Extensions must make use of the ExtensibleBot class - usually by creating an instance of it and using it as a jumping-off point. Extending the ExtensibleBot class Generally speaking, it's best to use ExtensibleBot directly and approach us if there's some functionality missing you need, but the option to extend it is always there if you have a very niche use-case. If you're not sure whether your use-case is appropriate for a wider public release, please open an issue - we're always happy to have a chat with you!","title":"The Bot Object"},{"location":"concepts/bot/#creating-a-bot","text":"The first thing you'll want to do is create an instance of ExtensibleBot. A basic setup looks something like this: 1 2 3 4 val token = \"...\" // Get your bot token val prefix = \"!\" // Prefix required before all command invocations val bot = ExtensibleBot ( token , prefix ) // Create the bot The ExtensibleBot constructor takes a number of arguments. We recommend supplying them using keyword arguments, just in case the order needs to be changed later on. Invoke command on mention Currently a bug exists that prevents the functionality referenced by invokeCommandOnMention from working. We'll look into this as soon as we can - but if you need this functionality for your bots, contact us and we'll prioritise it. Name Type Default Description token String The Discord bot token to login with prefix String The prefix required before all command invocations addHelpExtension Boolean true Whether to add the bundled help extension automatically addSentryExtension Boolean true Whether to add the bundled Sentry integration extension automatically invokeCommandOnMention Boolean true Whether commands may also be invoked by mentioning the bot messageCacheSize Int 10_000 How many messages to keep in the messages cache by default commandThreads Int CPUs * 2 How many threads to use for the command execution threadpool guildsToFill List <Snowflake> [ ] A list of guilds to request all members for during the connection phase. This requires the GuildMembers intent, specified in the start function fillPresences Boolean? null Whether to request presences for the above members ( true / false , or null for the default). This requires the GuildPresences intent, specified in the start function","title":"Creating a Bot"},{"location":"concepts/bot/#adding-extensions","text":"When you've written some Extensions , you'll need to add them to the bot before they can be used. This can be done at any point, but we recommend doing it before you connect to Discord, as many extensions rely on Discord's ReadyEvent to set up. 1 2 bot . addExtension ( LogsExtension :: class ) bot . addExtension ( TestExtension :: class )","title":"Adding extensions"},{"location":"concepts/bot/#starting-up","text":"When you're all set up, and you've registered all your extensions, you can call the start function to create a Kord instance and connect to Discord. 1 bot . start () This function takes a number of optional arguments which - just like before - you should supply using keyword arguments where possible. Not Implemented: Sharding Sharding is currently not supported. We haven't had a chance to look at it yet, as none of the developers are currently working on bots that require sharding. If you need sharding, please contact us and we can work out the details. Name Type Description presenceBuilder PresenceBuilder.() Provide a lambda here to set the bot's initial presence, defaulting to online with no activity intents IntentsBuilder.()? Provide a lambda here to provide a set of intents that your bot does and does not require","title":"Starting up"},{"location":"concepts/bot/#properties","text":"A few properties are available to you, for getting access to Kord or querying some of the bot's state. Further properties There are other non-private properties available, but they aren't necessarily something you'll need to touch. Most of the properties are open to facilitate niche use-cases that require extending the ExtensibleBot class. Name Type Description kord Kord Current connected Kord instance, if the bot has been started commands List <Command> All currently-registered command objects eventHandlers List <EventHandler> All currently-registered event handler objects extensions Map <String, Extension> All currently-loaded extension objects","title":"Properties"},{"location":"concepts/bot/#functions","text":"A number of functions are available to you as well. Further functions There are other non-private functions available, but they aren't necessarily something you'll need to touch. Most of the functions are open to facilitate niche use-cases that require extending the ExtensibleBot class, but a handful are inline for the sake of avoiding function call overhead. Name Description start Connect to Discord, blocking the coroutine scope send Send an event to all event handlers - either a Kord Event or an ExtensionEvent object addExtension Instantiate and load an extension loadExtension Set up a previously-unloaded extension unloadExtension Tear down a previously-loaded extension","title":"Functions"},{"location":"concepts/checks/","text":"Checks The checks system provides a way for you define and make use of predicates that decide whether an event handler or command should execute. The concept is relatively simple - all checks receive an event, check whether execution should continue based on that event, and return a Boolean value that decides what happens next - true to continue, false to stop. Anything that makes use of checks will accept either a lambda, or a function reference. This allows you to create reusable check functions that can be imported and made use of throughout your bot. Checks suite Kord Extensions comes with a full suite of commonly-used checks. This suite includes checks that operate based on specific types, combinator checks that provide boolean operations on sets of other checks, and a set of utilities for writing your own checks or extracting information from Kord events. Event not supported? If an event is not supported by a check that you feel should be, please raise an issue with us - we'll look into it as quickly as we can. Kord does not provide generic interfaces for figuring out which events concern different types of entity, so we have to manually maintain utilities that match specific events by their types. Channels Name Argument Description channelHigherOrEqual Channel Asserts that an event fired in a channel higher than or equal to the given channel channelHigher Channel Asserts that an event fired in a channel higher than the given channel channelLowerOrEqual Channel Asserts that an event fired in a channel lower than or equal to the given channel channelLower Channel Asserts that an event fired in a channel lower than the given channel inCategory Category Asserts that an event fired within the given channel category inChannel Channel Asserts that an event fired within the given channel notInCategory Category Asserts that an event did not fire within the given channel category notInChannel Channel Asserts that an event did not fire within the given channel Channel types Name Argument Description channelType ChannelType Asserts that an event fired within a channel matching the given type notChannelType ChannelType Asserts that an event did not fire within a channel matching the given type Guilds Name Argument Description inGuild Guild Asserts that an event fired within the given guild notInGuild Guild Asserts that an event did not fire within the given guild Roles Name Argument Description hasRole Role Asserts that an event was fired by a user with the given role notHasRole Role Asserts that an event was fired by a user without the given role topRoleEqual Role Asserts that an event was fired by a user with a top role that matches the given role topRoleHigherOrEqual Role Asserts that an event was fired by a user with a top role higher than or equal to the given role topRoleHigher Role Asserts that an event was fired by a user with a top role higher than the given role topRoleLowerOrEqual Role Asserts that an event was fired by a user with a top role lower than or equal to the given role topRoleLower Role Asserts that an event was fired by a user with a top role lower than the given role topRoleNotEqual Role Asserts that an event was fired by a user with a top role that does not match the given role Combinators Combinator checks operate on a variable number of other checks, transforming their results as appropriate. Name Argument Description and Checks Special check that passes if any of the given checks pass or Checks Special check that passes only if all of the given checks pass Utilities The following utilities are made use of in the other checks, but you can make use of them yourself if you need to try to extract a given type from any event. If an event is unsupported, then each of the below functions will return null . Please note that there are some events that these functions do support that may themselves return a nullable value when queried. Name Return Type Notes channelFor ChannelBehavior channelIdFor Long This function will return a Long taken from a Snowflake , rather than the Snowflake itself channelSnowflakeFor Snowflake This function is just like the previous, but will not unwrap the Snowflake guildFor GuildBehavior This function will query the Kord cache or REST for MessageCreateEvent and MessageUpdateEvent memberFor MemberBehavior This function will query the Kord cache or REST for all supported events except for MemberJoinEvent and MemberUpdateEvent messageFor MessageBehavior This function will query the Kord cache or REST for MessageUpdateEvent roleFor RoleBehavior userFor UserBehavior This function will query the Kord cache or REST for MessageUpdateEvent , and will only return the first user that isn't the bot for DMChannelCreateEvent , DMChannelDeleteEvent and DMChannelUpdateEvent (as we don't support selfbots) Creating reusable checks All checks may be defined as functions, and all check functions will accept a function reference. As an example, it's common practise to define a \"default\" check that applies to most commands like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 suspend fun defaultCheck ( event : Event ): Boolean { val logger = KotlinLogging . logger ( \"my.package.defaultCheck\" ) val message = messageFor ( event ) ?. asMessage () return when { message == null -> { logger . debug { \"Failing check: Message for event $event is null. This type of event may not be supported.\" } false } message . author == null -> { logger . debug { \"Failing check: Message sent by a webhook or system message\" } false } message . author !! . id == bot . kord . getSelf (). id -> { logger . debug { \"Failing check: We sent this message\" } false } message . author !! . isBot -> { logger . debug { \"Failing check: This message was sent by another bot\" } false } message . getChannelOrNull () is DmChannel -> { logger . debug { \"Passing check: This message was sent in a DM\" } true } message . getGuildOrNull () ?. id != config . getGuild (). id -> { logger . debug { \"Failing check: Not in the correct guild\" } false } else -> { logger . debug { \"Passing check\" } true } } } If you've written a check that you think would be useful for the majority users (and it can be written in a generic way) then feel free to open an issue or pull request, and we'll look at getting it added to the framework proper.","title":"Checks"},{"location":"concepts/checks/#checks","text":"The checks system provides a way for you define and make use of predicates that decide whether an event handler or command should execute. The concept is relatively simple - all checks receive an event, check whether execution should continue based on that event, and return a Boolean value that decides what happens next - true to continue, false to stop. Anything that makes use of checks will accept either a lambda, or a function reference. This allows you to create reusable check functions that can be imported and made use of throughout your bot.","title":"Checks"},{"location":"concepts/checks/#checks-suite","text":"Kord Extensions comes with a full suite of commonly-used checks. This suite includes checks that operate based on specific types, combinator checks that provide boolean operations on sets of other checks, and a set of utilities for writing your own checks or extracting information from Kord events. Event not supported? If an event is not supported by a check that you feel should be, please raise an issue with us - we'll look into it as quickly as we can. Kord does not provide generic interfaces for figuring out which events concern different types of entity, so we have to manually maintain utilities that match specific events by their types.","title":"Checks suite"},{"location":"concepts/checks/#channels","text":"Name Argument Description channelHigherOrEqual Channel Asserts that an event fired in a channel higher than or equal to the given channel channelHigher Channel Asserts that an event fired in a channel higher than the given channel channelLowerOrEqual Channel Asserts that an event fired in a channel lower than or equal to the given channel channelLower Channel Asserts that an event fired in a channel lower than the given channel inCategory Category Asserts that an event fired within the given channel category inChannel Channel Asserts that an event fired within the given channel notInCategory Category Asserts that an event did not fire within the given channel category notInChannel Channel Asserts that an event did not fire within the given channel","title":"Channels"},{"location":"concepts/checks/#channel-types","text":"Name Argument Description channelType ChannelType Asserts that an event fired within a channel matching the given type notChannelType ChannelType Asserts that an event did not fire within a channel matching the given type","title":"Channel types"},{"location":"concepts/checks/#guilds","text":"Name Argument Description inGuild Guild Asserts that an event fired within the given guild notInGuild Guild Asserts that an event did not fire within the given guild","title":"Guilds"},{"location":"concepts/checks/#roles","text":"Name Argument Description hasRole Role Asserts that an event was fired by a user with the given role notHasRole Role Asserts that an event was fired by a user without the given role topRoleEqual Role Asserts that an event was fired by a user with a top role that matches the given role topRoleHigherOrEqual Role Asserts that an event was fired by a user with a top role higher than or equal to the given role topRoleHigher Role Asserts that an event was fired by a user with a top role higher than the given role topRoleLowerOrEqual Role Asserts that an event was fired by a user with a top role lower than or equal to the given role topRoleLower Role Asserts that an event was fired by a user with a top role lower than the given role topRoleNotEqual Role Asserts that an event was fired by a user with a top role that does not match the given role","title":"Roles"},{"location":"concepts/checks/#combinators","text":"Combinator checks operate on a variable number of other checks, transforming their results as appropriate. Name Argument Description and Checks Special check that passes if any of the given checks pass or Checks Special check that passes only if all of the given checks pass","title":"Combinators"},{"location":"concepts/checks/#utilities","text":"The following utilities are made use of in the other checks, but you can make use of them yourself if you need to try to extract a given type from any event. If an event is unsupported, then each of the below functions will return null . Please note that there are some events that these functions do support that may themselves return a nullable value when queried. Name Return Type Notes channelFor ChannelBehavior channelIdFor Long This function will return a Long taken from a Snowflake , rather than the Snowflake itself channelSnowflakeFor Snowflake This function is just like the previous, but will not unwrap the Snowflake guildFor GuildBehavior This function will query the Kord cache or REST for MessageCreateEvent and MessageUpdateEvent memberFor MemberBehavior This function will query the Kord cache or REST for all supported events except for MemberJoinEvent and MemberUpdateEvent messageFor MessageBehavior This function will query the Kord cache or REST for MessageUpdateEvent roleFor RoleBehavior userFor UserBehavior This function will query the Kord cache or REST for MessageUpdateEvent , and will only return the first user that isn't the bot for DMChannelCreateEvent , DMChannelDeleteEvent and DMChannelUpdateEvent (as we don't support selfbots)","title":"Utilities"},{"location":"concepts/checks/#creating-reusable-checks","text":"All checks may be defined as functions, and all check functions will accept a function reference. As an example, it's common practise to define a \"default\" check that applies to most commands like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 suspend fun defaultCheck ( event : Event ): Boolean { val logger = KotlinLogging . logger ( \"my.package.defaultCheck\" ) val message = messageFor ( event ) ?. asMessage () return when { message == null -> { logger . debug { \"Failing check: Message for event $event is null. This type of event may not be supported.\" } false } message . author == null -> { logger . debug { \"Failing check: Message sent by a webhook or system message\" } false } message . author !! . id == bot . kord . getSelf (). id -> { logger . debug { \"Failing check: We sent this message\" } false } message . author !! . isBot -> { logger . debug { \"Failing check: This message was sent by another bot\" } false } message . getChannelOrNull () is DmChannel -> { logger . debug { \"Passing check: This message was sent in a DM\" } true } message . getGuildOrNull () ?. id != config . getGuild (). id -> { logger . debug { \"Failing check: Not in the correct guild\" } false } else -> { logger . debug { \"Passing check\" } true } } } If you've written a check that you think would be useful for the majority users (and it can be written in a generic way) then feel free to open an issue or pull request, and we'll look at getting it added to the framework proper.","title":"Creating reusable checks"},{"location":"concepts/commands/","text":"Commands If you want your bot to interact with users in a more complex manner than simply reacting to events, then you'll probably want to write some commands. Kord Extensions provides a robust and flexible commands system, built around a custom argument parsing solution that allows you to specify the arguments for your command in an entirely type-safe manner. We support both standalone and grouped commands, and you can even create your own specialised command types if you wish. That said, it's usually best to start with the basics. The basics Commands provide a way for you to specify a set of actions the bot can take on a user's behalf, specified using a prefixed message in a Discord channel or private message. Creating one is simple - just use the command function in your extension's setup function. 1 2 3 4 5 6 7 8 9 10 11 12 command { // this: Command name = \"ping\" // Command name aliases = arrayOf ( \"pong\" ) // Alternate command names description = \"Returns 'Pong!'\" // Help text for the help command check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: CommandContext message . respond ( \"Pong!\" ) } } Use the check function to define a set of predicates that must all return true in order for the command's action to be run - you can read more about checks on the Checks page . Once all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to a CommandContext object. Options Commands have quite a lot of options that you may be interested in while setting one up. The following properties are available right in the command lambda - please note that properties marked with are required and must be set in order to properly register a command. Name Type Description name String The primary name of the command, which must be unique throughout the bot and is used for invocation aliases Array <String> An array of secondary names to use for this command, which are also used for invocation and help commands description String A long description used by the help extension to describe the command - the first line of which should be a short summary enabled Boolean Defaulting to true , this can be set programmatically in order to entirely disable or re-enable the command hidden Boolean Default to false , this can be set to true to completely hide the command from the help extension's command listings signature String A string representing the arguments for the command - you can have this automatically generated using the signature() function as described later on in this document Additionally, the following functions are available - please note that functions marked with are required and must be called in order to properly register a command. Name Description action A DSL function allowing you to define the code that will be run when the command is invoked, either as a lambda or by passing a function reference check A function allowing you to define one or more checks for this command - see the Checks page for more information signature A function that will generate the command signature for you, when passed a function or constructor reference that returns an Arguments object, which will be described later on in this document Command context A CommandContext object is a light wrapper around the command invocation, and it exists only for the duration of your command's action . It exists to provide a little extra context and functionality for your command body CommandContext objects expose the following properties. Name Type Description args Array <String> A simple array of string arguments that were passed to this command invocation breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration command Command Current command being invoked event MessageCreateEvent MessageCreateEvent that is responsible for causing this command invocation message Message Message object from the event Additionally, CommandContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration . parse Given a function or constructor reference that returns an Arguments object, parses the command's arguments and returns a filled Arguments object - see below for more information Command arguments Kord Extensions provides an object-based approach to argument parsing, using a base Arguments type and delegation to extension functions. Defining the arguments for your command is fairly simple: 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" ) // Single required Discord user argument val author by user ( \"author\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" ) } We recommend writing this as an inner class, but it's up to you where you put it (as long as it's public). Once you've created your argument class, you can start using it in your commands: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 command { name = \"post\" description = \"Create a post\" signature ( :: PostArguments ) action { // Option 1 val parsed = parse ( :: PostArguments ) message . respond ( \"**${parsed.title}** (by ${parsed.author.mention})\\n\\n\" + parsed . body ) // Option 2 with ( parse ( :: PostArguments )) { message . respond ( \"**$title** (by ${author.mention})\\n\\n\" + body ) } } } The argument parser will validate the command arguments for you automatically - if there's a problem, a ParseException will be thrown. These exceptions are automatically handled by the bot, and will be returned to whoever invoked the command to let them know what exactly went wrong. For more information on how exactly this parsing works (and how to customize it), please see the Converters page . Command groups For ease of use, we also provide a special type of command that includes the ability to nest commands within it. Grouped commands work just like regular commands, but with a few differences: Grouped commands have a default action that informs the user of the available subcommands, which means you don't have to define an action unless you want to override this behaviour Grouped commands have their own command and group functions that can be used for nesting Checks are tested while traversing the tree, which means that a parent's checks must pass for a subcommand to execute The help extension also fully supports subcommands, and understands what you meant if you try to request help for a subcommand - just provide the full command, and you're good to go. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 group { name = \"sport\" description = \"Set your favourite sport!\" command { name = \"basketball\" description = \"Set your favourite sport to basketball\" action { message . respond ( \"Your favourite sport is now basketball.\" ) } } command { name = \"football\" description = \"Set your favourite sport to football\" action { message . respond ( \"Your favourite sport is now football.\" ) } } group { name = \"craft\" description = \"Sports are boring, pick a craft instead!\" command { name = \"knitting\" description = \"Set your favourite sport to knitting\" action { message . respond ( \"Your favourite sport is now knitting.\" ) } } command { name = \"painting\" description = \"Set your favourite sport to painting\" action { message . respond ( \"Your favourite sport is now painting.\" ) } } } } Command parsing While not everyone will need to understand precisely how commands are parsed under the hood, it's worth exploring some specifics - you'll need to understand how to specify arguments on Discord, and your users will likewise need an understanding of this. Kord Extensions supports two ways to supply arguments out of the box: Positional arguments, and keyword arguments. You can mix both approaches; arguments will always be parsed in the order they're defined in the Arguments subclass, but keyword arguments can appear anywhere in the command (aside from inside another argument). Positional arguments are always parsed in order. Not Implemented: Flags Occasionally, a user will ask us why our parser doesn't support Unix-style flags - for example, --argument or -a value . The primary reason for this is that the current argument parser is already fairly complex, and supporting flags within it would massively increase the maintenance burden it already carries. Additionally, while developers and Linux users will be very familiar with flags, we don't feel that most users will find them as simple to understand as our current keyword arguments. That said, you're always free to subclass the ArgumentParser class and implement your own parsing - if you do anything interesting with this, please let us know! Additionally, single arguments can contain spaces if you \"surround them in quotes\" . As an example, take the following command: 1 2 3 4 5 !post author=109040264529608704 \"This is my title\" **My Post** This is part of the body of my post, despite being a couple lines down. Arguments can happily contain newlines - although arguments can't be *separated* using newlines, so be careful! Assuming a command prefix of ! : Our command is named post Next, a keyword argument referring to author is found, and a reference is stored title is parsed first, into the string \"This is my title\" Next, author is parsed - the bot will search for a user with the given ID, but a mention or user#discrim string can also be provided instead Finally, body is parsed - it's a coalescing string converter, so it consumes the rest of the arguments This is a fairly simple example, and you can write some fairly complicated command handling if you feel so inclined. Consuming multiple arguments Multi and coalescing converters consume arguments until they come across something they can no longer consume - for example, the numberList extension function returns a MultiConverter that consumes whole numbers until it no longer can. It will consume numbers from its starting argument onwards, until it encounters something that isn't a number. At that point, it stops and tells the argument parser how many arguments have been consumed, and processing continues to the next converter. Extensible converters Converters themselves are quite extensible, and you shouldn't be afraid to write custom converters for types that are unique to your bot. Additionally, the order of the arguments defined in your Arguments subclass will be matched by the parser, so it is technically possible to create a converter that, for example, takes a lambda that relies on the value of a previously specified argument. Custom command types Kord Extensions provides three command types ( Command , GroupCommand and SubCommand ), which should be fairly self-explanatory. You can also create your own command types by subclassing Command and overriding different properties and functions. Some properties you may be interested in include: Name Type Description body CommandContext.() The command body, normally set using the action function checkList MutableList <MessageCreateEvent -> Boolean> A list of check predicates required for command execution parser ArgumentParser Class in charge of handling argument parsing, which you can override if you'd like to change how that works The following functions may also be interesting for subclasses: Name Description runChecks Function in charge of running all the checks and reporting its success call Function called to handle the actual command invocation - a lot of things happen here, you'll want to read the source before overriding this As the command system is still constantly evolving, you'll want to keep up with releases and double-check for breakages in your custom command types. Despite this maintenance burden, custom command types have a lot of uses - so feel free to experiment!","title":"Commands"},{"location":"concepts/commands/#commands","text":"If you want your bot to interact with users in a more complex manner than simply reacting to events, then you'll probably want to write some commands. Kord Extensions provides a robust and flexible commands system, built around a custom argument parsing solution that allows you to specify the arguments for your command in an entirely type-safe manner. We support both standalone and grouped commands, and you can even create your own specialised command types if you wish. That said, it's usually best to start with the basics.","title":"Commands"},{"location":"concepts/commands/#the-basics","text":"Commands provide a way for you to specify a set of actions the bot can take on a user's behalf, specified using a prefixed message in a Discord channel or private message. Creating one is simple - just use the command function in your extension's setup function. 1 2 3 4 5 6 7 8 9 10 11 12 command { // this: Command name = \"ping\" // Command name aliases = arrayOf ( \"pong\" ) // Alternate command names description = \"Returns 'Pong!'\" // Help text for the help command check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: CommandContext message . respond ( \"Pong!\" ) } } Use the check function to define a set of predicates that must all return true in order for the command's action to be run - you can read more about checks on the Checks page . Once all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to a CommandContext object.","title":"The basics"},{"location":"concepts/commands/#options","text":"Commands have quite a lot of options that you may be interested in while setting one up. The following properties are available right in the command lambda - please note that properties marked with are required and must be set in order to properly register a command. Name Type Description name String The primary name of the command, which must be unique throughout the bot and is used for invocation aliases Array <String> An array of secondary names to use for this command, which are also used for invocation and help commands description String A long description used by the help extension to describe the command - the first line of which should be a short summary enabled Boolean Defaulting to true , this can be set programmatically in order to entirely disable or re-enable the command hidden Boolean Default to false , this can be set to true to completely hide the command from the help extension's command listings signature String A string representing the arguments for the command - you can have this automatically generated using the signature() function as described later on in this document Additionally, the following functions are available - please note that functions marked with are required and must be called in order to properly register a command. Name Description action A DSL function allowing you to define the code that will be run when the command is invoked, either as a lambda or by passing a function reference check A function allowing you to define one or more checks for this command - see the Checks page for more information signature A function that will generate the command signature for you, when passed a function or constructor reference that returns an Arguments object, which will be described later on in this document","title":"Options"},{"location":"concepts/commands/#command-context","text":"A CommandContext object is a light wrapper around the command invocation, and it exists only for the duration of your command's action . It exists to provide a little extra context and functionality for your command body CommandContext objects expose the following properties. Name Type Description args Array <String> A simple array of string arguments that were passed to this command invocation breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration command Command Current command being invoked event MessageCreateEvent MessageCreateEvent that is responsible for causing this command invocation message Message Message object from the event Additionally, CommandContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration . parse Given a function or constructor reference that returns an Arguments object, parses the command's arguments and returns a filled Arguments object - see below for more information","title":"Command context"},{"location":"concepts/commands/#command-arguments","text":"Kord Extensions provides an object-based approach to argument parsing, using a base Arguments type and delegation to extension functions. Defining the arguments for your command is fairly simple: 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" ) // Single required Discord user argument val author by user ( \"author\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" ) } We recommend writing this as an inner class, but it's up to you where you put it (as long as it's public). Once you've created your argument class, you can start using it in your commands: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 command { name = \"post\" description = \"Create a post\" signature ( :: PostArguments ) action { // Option 1 val parsed = parse ( :: PostArguments ) message . respond ( \"**${parsed.title}** (by ${parsed.author.mention})\\n\\n\" + parsed . body ) // Option 2 with ( parse ( :: PostArguments )) { message . respond ( \"**$title** (by ${author.mention})\\n\\n\" + body ) } } } The argument parser will validate the command arguments for you automatically - if there's a problem, a ParseException will be thrown. These exceptions are automatically handled by the bot, and will be returned to whoever invoked the command to let them know what exactly went wrong. For more information on how exactly this parsing works (and how to customize it), please see the Converters page .","title":"Command arguments"},{"location":"concepts/commands/#command-groups","text":"For ease of use, we also provide a special type of command that includes the ability to nest commands within it. Grouped commands work just like regular commands, but with a few differences: Grouped commands have a default action that informs the user of the available subcommands, which means you don't have to define an action unless you want to override this behaviour Grouped commands have their own command and group functions that can be used for nesting Checks are tested while traversing the tree, which means that a parent's checks must pass for a subcommand to execute The help extension also fully supports subcommands, and understands what you meant if you try to request help for a subcommand - just provide the full command, and you're good to go. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 group { name = \"sport\" description = \"Set your favourite sport!\" command { name = \"basketball\" description = \"Set your favourite sport to basketball\" action { message . respond ( \"Your favourite sport is now basketball.\" ) } } command { name = \"football\" description = \"Set your favourite sport to football\" action { message . respond ( \"Your favourite sport is now football.\" ) } } group { name = \"craft\" description = \"Sports are boring, pick a craft instead!\" command { name = \"knitting\" description = \"Set your favourite sport to knitting\" action { message . respond ( \"Your favourite sport is now knitting.\" ) } } command { name = \"painting\" description = \"Set your favourite sport to painting\" action { message . respond ( \"Your favourite sport is now painting.\" ) } } } }","title":"Command groups"},{"location":"concepts/commands/#command-parsing","text":"While not everyone will need to understand precisely how commands are parsed under the hood, it's worth exploring some specifics - you'll need to understand how to specify arguments on Discord, and your users will likewise need an understanding of this. Kord Extensions supports two ways to supply arguments out of the box: Positional arguments, and keyword arguments. You can mix both approaches; arguments will always be parsed in the order they're defined in the Arguments subclass, but keyword arguments can appear anywhere in the command (aside from inside another argument). Positional arguments are always parsed in order. Not Implemented: Flags Occasionally, a user will ask us why our parser doesn't support Unix-style flags - for example, --argument or -a value . The primary reason for this is that the current argument parser is already fairly complex, and supporting flags within it would massively increase the maintenance burden it already carries. Additionally, while developers and Linux users will be very familiar with flags, we don't feel that most users will find them as simple to understand as our current keyword arguments. That said, you're always free to subclass the ArgumentParser class and implement your own parsing - if you do anything interesting with this, please let us know! Additionally, single arguments can contain spaces if you \"surround them in quotes\" . As an example, take the following command: 1 2 3 4 5 !post author=109040264529608704 \"This is my title\" **My Post** This is part of the body of my post, despite being a couple lines down. Arguments can happily contain newlines - although arguments can't be *separated* using newlines, so be careful! Assuming a command prefix of ! : Our command is named post Next, a keyword argument referring to author is found, and a reference is stored title is parsed first, into the string \"This is my title\" Next, author is parsed - the bot will search for a user with the given ID, but a mention or user#discrim string can also be provided instead Finally, body is parsed - it's a coalescing string converter, so it consumes the rest of the arguments This is a fairly simple example, and you can write some fairly complicated command handling if you feel so inclined. Consuming multiple arguments Multi and coalescing converters consume arguments until they come across something they can no longer consume - for example, the numberList extension function returns a MultiConverter that consumes whole numbers until it no longer can. It will consume numbers from its starting argument onwards, until it encounters something that isn't a number. At that point, it stops and tells the argument parser how many arguments have been consumed, and processing continues to the next converter. Extensible converters Converters themselves are quite extensible, and you shouldn't be afraid to write custom converters for types that are unique to your bot. Additionally, the order of the arguments defined in your Arguments subclass will be matched by the parser, so it is technically possible to create a converter that, for example, takes a lambda that relies on the value of a previously specified argument.","title":"Command parsing"},{"location":"concepts/commands/#custom-command-types","text":"Kord Extensions provides three command types ( Command , GroupCommand and SubCommand ), which should be fairly self-explanatory. You can also create your own command types by subclassing Command and overriding different properties and functions. Some properties you may be interested in include: Name Type Description body CommandContext.() The command body, normally set using the action function checkList MutableList <MessageCreateEvent -> Boolean> A list of check predicates required for command execution parser ArgumentParser Class in charge of handling argument parsing, which you can override if you'd like to change how that works The following functions may also be interesting for subclasses: Name Description runChecks Function in charge of running all the checks and reporting its success call Function called to handle the actual command invocation - a lot of things happen here, you'll want to read the source before overriding this As the command system is still constantly evolving, you'll want to keep up with releases and double-check for breakages in your custom command types. Despite this maintenance burden, custom command types have a lot of uses - so feel free to experiment!","title":"Custom command types"},{"location":"concepts/converters/","text":"Converters Converters are small classes that exist to convert strings - or groups of strings - into other types. They make up the core of the argument parsing provided with Kord Extensions, allowing you to easily parse command arguments into complex types with no compiler plugins, generated Kotlin or reflection whatsoever. Converter types In the interests of making sure you never get a type you're not expecting, Kord Extensions ships with a wide variety of converters. Converters are first classified by the way they behave, and then by the type they exist to convert to. The basic converter types are as follows: Type Description CoalescingConverter A converter representing a required argument converted from a list of strings, combined into a single value DefaultingConverter A converter representing a single argument with a default value, converted from up to one supplied string MultiConverter A converter representing an argument converted from a list of strings, one value per string - which may be either required or optional OptionalConverter A converter representing a single, optional/nullable argument converted from up to one supplied string SingleConverter A converter representing a single, required argument converted from exactly one supplied string There are also some compound converters, which combine the behaviours found in other converters, such as: DefaultingCoalescingConverter OptionalCoalescingConverter We also provide some special implementations that wrap other converters, such as: CoalescingToDefaultingConverter (obtained via CoalescingConverter#toDefaulting() ) CoalescingToOptionalConverter (obtained via CoalescingConverter#toOptional() ) SingleToDefaultingConverter (obtained via SingleConverter#toDefaulting() ) SingleToMultiConverter (obtained via SingleConverter#toMulti() ) SingleToOptionalConverter (obtained via SingleConverter#toOptional() ) We recommend exploring the source code for these converters, as we're likely to continue adding them. Bundled converters Converters are provided that support the following type conversions, out of the box: Boolean Channel Decimal (Doubles only) Duration (Java Time and Time4J) with special-casing for coalescing conversion Email Emoji (Server emoji on Discord) Enum (Any enums you like, including those you define yourself) Guild Member Message Number (Longs only) Regex (Kotlin wrapper type only) with special-casing for coalescing conversion Role String with special-casing for coalescing conversion User Usage Converters are intended to be used as part of your commands setup, via the Arguments object. Arguments is a special type that contains a list of each of the delegated properties in your class, in order - placed there by specially-created extension functions that create converters for you. Here's an example, from the Commands page . 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" ) // Single required Discord user argument val author by user ( \"author\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" ) } In this example, we have three arguments: title - a required String argument, with the friendly name of \"title\" author - a required Discord User argument, with the friendly name of \"author\" body - A required coalescing String argument, with the friendly name of \"body\" All arguments require a friendly name. This name will be used to refer to that argument in the command's signature, as well as error and other help messages. It's also the name that will be used for keyword arguments. On top of this, different converters (and types of converters) may take extra arguments. For example, all defaulting converters require you to pass a default value to their creation function, while optional converters do not take a default value and instead will return null by default. Finding converter functions As of this writing, there are over 700 lines covering Arguments object extension functions. While you can read the generated Dokka documentation for a full list, we recommend making use of your IDE's auto-completion functionality for discovery - especially if you've written custom converters, or you're making use of third-party converters. Custom converters If you'd like to convert arguments to a type that we don't currently support, or you'd like to add some extra validation to arguments, then custom converters are the way to go. Depending on what you're doing, you'll want to start by subclassing one of the following converter base classes: SingleConverter for single converters, which can be wrapped into defaulting, multi and optional converters CoalescingConverter for coalescing converters, which can be wrapped into defaulting and optional variants When creating your converter, one of the biggest things you can do to help yourself is to read over the Dokka generated documentation for the base classes, and look at the source for the bundled converters. Custom converters can be a little tricky to get your head around at first, so feel free to join the Kotlin Discord server if you need to ask questions. How do I bail when something goes wrong? As you may expect, errors are handled using Kotlin's exceptions system. Exceptions can be thrown as normal, and they'll be caught by the argument parser and transformed into an error message. However, you may wish to provide a more useful error message to the user - for these cases, you should create and throw an instance of ParseException yourself. The message passed to ParseException will be returned to the user verbatim, so make it descriptive! Remember that your end users are not necessarily developers! Most people will not understand a technical description or a default exception message - any ParseException instances you throw should contain a human-readable error message that tells the user what went wrong so that they can correct their command invocation and try again. If you need to provide developer-oriented feedback, use a logger! Because of this, only ParseException instances will be returned to the user verbatim. All other exception types will be logged, and a generic error message will be returned to the user. Once you've created your converters, we recommend writing Arguments extension functions for them. As before, we heavily recommend reading the source for the extension functions that already exist - they're quite simple, but it always pays to try to write the best APIs you can, especially if you expect someone else to make use of your code someday!","title":"Converters"},{"location":"concepts/converters/#converters","text":"Converters are small classes that exist to convert strings - or groups of strings - into other types. They make up the core of the argument parsing provided with Kord Extensions, allowing you to easily parse command arguments into complex types with no compiler plugins, generated Kotlin or reflection whatsoever.","title":"Converters"},{"location":"concepts/converters/#converter-types","text":"In the interests of making sure you never get a type you're not expecting, Kord Extensions ships with a wide variety of converters. Converters are first classified by the way they behave, and then by the type they exist to convert to. The basic converter types are as follows: Type Description CoalescingConverter A converter representing a required argument converted from a list of strings, combined into a single value DefaultingConverter A converter representing a single argument with a default value, converted from up to one supplied string MultiConverter A converter representing an argument converted from a list of strings, one value per string - which may be either required or optional OptionalConverter A converter representing a single, optional/nullable argument converted from up to one supplied string SingleConverter A converter representing a single, required argument converted from exactly one supplied string There are also some compound converters, which combine the behaviours found in other converters, such as: DefaultingCoalescingConverter OptionalCoalescingConverter We also provide some special implementations that wrap other converters, such as: CoalescingToDefaultingConverter (obtained via CoalescingConverter#toDefaulting() ) CoalescingToOptionalConverter (obtained via CoalescingConverter#toOptional() ) SingleToDefaultingConverter (obtained via SingleConverter#toDefaulting() ) SingleToMultiConverter (obtained via SingleConverter#toMulti() ) SingleToOptionalConverter (obtained via SingleConverter#toOptional() ) We recommend exploring the source code for these converters, as we're likely to continue adding them.","title":"Converter types"},{"location":"concepts/converters/#bundled-converters","text":"Converters are provided that support the following type conversions, out of the box: Boolean Channel Decimal (Doubles only) Duration (Java Time and Time4J) with special-casing for coalescing conversion Email Emoji (Server emoji on Discord) Enum (Any enums you like, including those you define yourself) Guild Member Message Number (Longs only) Regex (Kotlin wrapper type only) with special-casing for coalescing conversion Role String with special-casing for coalescing conversion User","title":"Bundled converters"},{"location":"concepts/converters/#usage","text":"Converters are intended to be used as part of your commands setup, via the Arguments object. Arguments is a special type that contains a list of each of the delegated properties in your class, in order - placed there by specially-created extension functions that create converters for you. Here's an example, from the Commands page . 1 2 3 4 5 6 7 8 9 10 class PostArguments : Arguments () { // Single required string argument val title by string ( \"title\" ) // Single required Discord user argument val author by user ( \"author\" ) // Consumes the rest of the arguments into a single string val body by coalescedString ( \"body\" ) } In this example, we have three arguments: title - a required String argument, with the friendly name of \"title\" author - a required Discord User argument, with the friendly name of \"author\" body - A required coalescing String argument, with the friendly name of \"body\" All arguments require a friendly name. This name will be used to refer to that argument in the command's signature, as well as error and other help messages. It's also the name that will be used for keyword arguments. On top of this, different converters (and types of converters) may take extra arguments. For example, all defaulting converters require you to pass a default value to their creation function, while optional converters do not take a default value and instead will return null by default. Finding converter functions As of this writing, there are over 700 lines covering Arguments object extension functions. While you can read the generated Dokka documentation for a full list, we recommend making use of your IDE's auto-completion functionality for discovery - especially if you've written custom converters, or you're making use of third-party converters.","title":"Usage"},{"location":"concepts/converters/#custom-converters","text":"If you'd like to convert arguments to a type that we don't currently support, or you'd like to add some extra validation to arguments, then custom converters are the way to go. Depending on what you're doing, you'll want to start by subclassing one of the following converter base classes: SingleConverter for single converters, which can be wrapped into defaulting, multi and optional converters CoalescingConverter for coalescing converters, which can be wrapped into defaulting and optional variants When creating your converter, one of the biggest things you can do to help yourself is to read over the Dokka generated documentation for the base classes, and look at the source for the bundled converters. Custom converters can be a little tricky to get your head around at first, so feel free to join the Kotlin Discord server if you need to ask questions. How do I bail when something goes wrong? As you may expect, errors are handled using Kotlin's exceptions system. Exceptions can be thrown as normal, and they'll be caught by the argument parser and transformed into an error message. However, you may wish to provide a more useful error message to the user - for these cases, you should create and throw an instance of ParseException yourself. The message passed to ParseException will be returned to the user verbatim, so make it descriptive! Remember that your end users are not necessarily developers! Most people will not understand a technical description or a default exception message - any ParseException instances you throw should contain a human-readable error message that tells the user what went wrong so that they can correct their command invocation and try again. If you need to provide developer-oriented feedback, use a logger! Because of this, only ParseException instances will be returned to the user verbatim. All other exception types will be logged, and a generic error message will be returned to the user. Once you've created your converters, we recommend writing Arguments extension functions for them. As before, we heavily recommend reading the source for the extension functions that already exist - they're quite simple, but it always pays to try to write the best APIs you can, especially if you expect someone else to make use of your code someday!","title":"Custom converters"},{"location":"concepts/events/","text":"Events Events represent a single action, either by a user, Discord itself, or your bot. They're one of the primary ways your bot will react to things happening on Discord, and they're an absolute essential concept to grasp. Subclassing these types While the event handler and context types that are about to be described do support subclassing, we do not currently provide a way to provide your subclasses in the typical fashion you'd want to use them. If you have a use-case for this then please let us know, and we'll prioritise it! Event Handlers In order to react to events, you'll need to add an event handler to your extension. Event handlers represent blocks of code that will be run in response to an event, along with some associated metadata. Creating one is simple - just use the event function in your extension's setup function. 1 2 3 4 5 6 7 8 event < EventClass > { // this: EventHandler<EventClass> check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: EventContext // Code to run when the event is received } } Use the check function to define a set of predicates that must all return true in order for the event handler to be run - you can read more about checks on the Checks page . Once all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to an EventContext object. Event Context An EventContext object is a light wrapper around the event type you're working with, and it exists only for the duration of your event handler's action . It exists to provide a little extra context and functionality for your event handler. EventContext objects expose the following properties, where T is the same type as the event being handled. Name Type Description breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration eventHandler EventHandler <T> Current event handler instance event T Current event being handled Additionally, EventContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration Event Types Kord Extensions supports every Kord event, which you can find in Kord's documentation . Kord events are the primary type of event that any bot will be making use of, so it's important to explore Kord's events and figure out what you're going to need. Additionally, Kord Extensions supports custom events. The following additional event types are provided: Type Description ExtensionLoadedEvent Fired when an extension is loaded, either on first load or programmatically later. ExtensionUnloadedEvent Fired when an extension is unloaded programmatically. Custom Events A custom event may essentially be any type, but events are matched on their types - for example, you can't match specific strings, only the String type. For this reason, the ExtensionEvent interface exists - implement it for your event objects, and use the types you create for matching in your event handlers. To fire your event, you can use the send convenience function on the ExtensibleBot object. 1 2 3 4 5 class NoteEvent ( bot : ExtensibleBot , val note : String ) : ExtensionEvent ( bot ) // ... bot . send ( NoteEvent ( bot , \"Sample note\" )) There are no restrictions on what your event can contain or what functionality it exposes. If it makes sense to have a mutable event, feel free!","title":"Events"},{"location":"concepts/events/#events","text":"Events represent a single action, either by a user, Discord itself, or your bot. They're one of the primary ways your bot will react to things happening on Discord, and they're an absolute essential concept to grasp. Subclassing these types While the event handler and context types that are about to be described do support subclassing, we do not currently provide a way to provide your subclasses in the typical fashion you'd want to use them. If you have a use-case for this then please let us know, and we'll prioritise it!","title":"Events"},{"location":"concepts/events/#event-handlers","text":"In order to react to events, you'll need to add an event handler to your extension. Event handlers represent blocks of code that will be run in response to an event, along with some associated metadata. Creating one is simple - just use the event function in your extension's setup function. 1 2 3 4 5 6 7 8 event < EventClass > { // this: EventHandler<EventClass> check { event -> true } // Return `false` to prevent the action check ( :: returnTrue ) // You can also pass it a function action { // this: EventContext // Code to run when the event is received } } Use the check function to define a set of predicates that must all return true in order for the event handler to be run - you can read more about checks on the Checks page . Once all the checks pass, the action lambda will be called. Note that the action lambda above is a receiver function, where this is bound to an EventContext object.","title":"Event Handlers"},{"location":"concepts/events/#event-context","text":"An EventContext object is a light wrapper around the event type you're working with, and it exists only for the duration of your event handler's action . It exists to provide a little extra context and functionality for your event handler. EventContext objects expose the following properties, where T is the same type as the event being handled. Name Type Description breadcrumbs MutableList <Breadcrumb> List of Sentry breadcrumbs, for the Sentry intgration eventHandler EventHandler <T> Current event handler instance event T Current event being handled Additionally, EventContext objects expose the following functions. Name Description breadcrumb Convenience function to create and add a Sentry breadcrumb, for the Sentry intgration","title":"Event Context"},{"location":"concepts/events/#event-types","text":"Kord Extensions supports every Kord event, which you can find in Kord's documentation . Kord events are the primary type of event that any bot will be making use of, so it's important to explore Kord's events and figure out what you're going to need. Additionally, Kord Extensions supports custom events. The following additional event types are provided: Type Description ExtensionLoadedEvent Fired when an extension is loaded, either on first load or programmatically later. ExtensionUnloadedEvent Fired when an extension is unloaded programmatically.","title":"Event Types"},{"location":"concepts/events/#custom-events","text":"A custom event may essentially be any type, but events are matched on their types - for example, you can't match specific strings, only the String type. For this reason, the ExtensionEvent interface exists - implement it for your event objects, and use the types you create for matching in your event handlers. To fire your event, you can use the send convenience function on the ExtensibleBot object. 1 2 3 4 5 class NoteEvent ( bot : ExtensibleBot , val note : String ) : ExtensionEvent ( bot ) // ... bot . send ( NoteEvent ( bot , \"Sample note\" )) There are no restrictions on what your event can contain or what functionality it exposes. If it makes sense to have a mutable event, feel free!","title":"Custom Events"},{"location":"concepts/extensions/","text":"Extensions Extensions represent defined units of functionality. They provide a way for you to group event handling and command logic together into logical blocks that can be managed individually from each other. While it is technically possible to create commands and event handlers without extensions, we recommend extensions for all use-cases. If you have a use-case that extensions don't cover, please let us know. Extensions support the following features: String name references and public APIs Loading/unloading at runtime, with custom setup/teardown logic Registered event handlers with custom event support Standalone commands with rich metadata Infinitely nestable command groups Extension basics When writing an extension, the first thing you'll need to do is extend the Extension class and implement its abstract members - the name property and setup function. 1 2 3 4 5 6 7 8 class TextExtension ( bot : ExtensibleBot ) : Extension ( bot ) { // The name this extension will be referred to by override val name : String = \"test\" override suspend fun setup () { // The majority of our extension logic goes here } } Once we've created our extension object, we'll need to register it to our bot object . 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token , prefix ) suspend fun main () { bot . addExtension ( TestExtension :: class ) bot . login () } Our basic extension is complete - it'll be loaded up and functional by the time the bot has connected to Discord. That said, it's a bit boring - let's try adding some functionality to it. There are three common behavioural patterns your extension is likely to implement. Reacting to events As an example, say we wanted to reply to users that say \"ping\" with \"pong\". For this contrived example, we could write an event handler that reacts to message creation events. 1 2 3 4 5 6 7 8 9 10 // Within your extension class... override suspend fun setup () { event < MessageCreateEvent > { action { if ( it . message . content . equals ( \"ping\" , true )) { it . message . respond ( \"pong\" ) } } } } Custom events This is not limited to Kord events - pretty much any object can be an event, although we recommend extending ExtensionEvent for your own events. To send an event, you can use ExtensibleBot#send(event) . For more information on working with events, please see the events page . Reacting to commands Commands are one of the most common methods of interaction with any Discord bot. For this reason, Kord Extensions provides a comprehensive, rich commands framework. For example, we could rewrite the ping example above as a command instead. 1 2 3 4 5 6 7 8 9 override suspend fun setup () { command { name = \"ping\" action { message . respond ( \"pong\" ) } } } Further functionality The commands framework is a deep, rich and feature-filled system that aims to support bot developers by making it as simple as possible to define commands that validate themselves and automatically parse their arguments. It also provides a set of classes that can be extended in order to further customize the behaviour of the commands system. The future of commands Parts of the commands framework are in the middle of being rewritten. That said, the commands system should be stable between versions - that is to say, we'll increment the version number before breaking it. We're hoping to expand upon this system in future, starting with a command dispatcher system that allows you to specify additional command dispatchers with their own prefixes and sets of commands, and switch out the argument parser used. This is a long way off, though, so we recommend keeping an eye on the GitHub repository if you're waiting for this. For more information on working with commands, please see the commands page . Polling and relaying For some bots, you'll need to work with external services. A common use-case is polling an external service and posting changes to a Discord channel, which you can do with Kotlin's Jobs. For this example, we'll write a quick extension that polls something every 30 seconds, and sends a message to a channel with updates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 30 seconds in milliseconds private const val INTERVAL = 1000L * 30L // 10 seconds in milliseconds - use this if you need to wait for // guild members (for example) to be populated. private const val SETUP_DELAY = 1000L * 10L class CheckExtension ( bot : ExtensibleBot ) : Extension ( bot ) { override val name : String = \"check\" private var data : String = \"\" // ...or whatever private var job : Job ? = null override suspend fun setup () { // Iniital setup should always happen after the ReadyEvent. This // is because the ReadyEvent handler has some special logic. // You can read more about that on the events page. event < ReadyEvent > { action { delay ( SETUP_DELAY ) // Launch a job in Kord's coroutine scope job = bot . kord . launch { while ( true ) { delay ( INTERVAL ) val changed = doCheck () // Whatever it is if ( changed ) { getChannel (). createMessage ( \"Data updated: $data\" ) } } } } } } override suspend fun unload () { // This will be called if the extension is unloaded at any point, // we should stop the job if that happens. job ?. cancel () } } The important thing to note here is that we're launching the job in Kord's coroutine scope, which gives us a Job object we can keep track of. While extensions won't be automatically unloaded, extensions are able to load and unload each other, and all extensions are expected to support this behaviour. If you can't support unloading in your extension for some reason, remember to override unload() and throw an exception! Class Members The Extension class exposes several useful members, and some internal ones. Because we can't possibly know exactly what you need from this system, we don't hide the functional parts - but the below table will mark the things you probably don't need with a . Properties Name Type Description name String The name of the extension, which is how it'll be referred to throughout the bot. eventHandlers MutableList <EventHandler> List of event handlers registered to this extension. commands MutableList <Command> List of commands registered to this extension. loaded Boolean Whether the extension is currently loaded - this is set automatically. Functions Name Description command Create a new command for this extension. event Create a new event handler for this extension. group Create a new grouped command for this extension (a command that can have subcommands). setup Override this and add all of your setup logic for the extension. unload Override this if you need to clean up when your extension is unloaded. doSetup Called by the bot when setting up the extension, firing events and handling extra setup tasks. doUnload Called by the bot when unloading the extension, firing events, unregistering event handlers and commands and handling extra cleanup.","title":"Extensions"},{"location":"concepts/extensions/#extensions","text":"Extensions represent defined units of functionality. They provide a way for you to group event handling and command logic together into logical blocks that can be managed individually from each other. While it is technically possible to create commands and event handlers without extensions, we recommend extensions for all use-cases. If you have a use-case that extensions don't cover, please let us know. Extensions support the following features: String name references and public APIs Loading/unloading at runtime, with custom setup/teardown logic Registered event handlers with custom event support Standalone commands with rich metadata Infinitely nestable command groups","title":"Extensions"},{"location":"concepts/extensions/#extension-basics","text":"When writing an extension, the first thing you'll need to do is extend the Extension class and implement its abstract members - the name property and setup function. 1 2 3 4 5 6 7 8 class TextExtension ( bot : ExtensibleBot ) : Extension ( bot ) { // The name this extension will be referred to by override val name : String = \"test\" override suspend fun setup () { // The majority of our extension logic goes here } } Once we've created our extension object, we'll need to register it to our bot object . 1 2 3 4 5 6 7 val bot = ExtensibleBot ( token , prefix ) suspend fun main () { bot . addExtension ( TestExtension :: class ) bot . login () } Our basic extension is complete - it'll be loaded up and functional by the time the bot has connected to Discord. That said, it's a bit boring - let's try adding some functionality to it. There are three common behavioural patterns your extension is likely to implement.","title":"Extension basics"},{"location":"concepts/extensions/#reacting-to-events","text":"As an example, say we wanted to reply to users that say \"ping\" with \"pong\". For this contrived example, we could write an event handler that reacts to message creation events. 1 2 3 4 5 6 7 8 9 10 // Within your extension class... override suspend fun setup () { event < MessageCreateEvent > { action { if ( it . message . content . equals ( \"ping\" , true )) { it . message . respond ( \"pong\" ) } } } } Custom events This is not limited to Kord events - pretty much any object can be an event, although we recommend extending ExtensionEvent for your own events. To send an event, you can use ExtensibleBot#send(event) . For more information on working with events, please see the events page .","title":"Reacting to events"},{"location":"concepts/extensions/#reacting-to-commands","text":"Commands are one of the most common methods of interaction with any Discord bot. For this reason, Kord Extensions provides a comprehensive, rich commands framework. For example, we could rewrite the ping example above as a command instead. 1 2 3 4 5 6 7 8 9 override suspend fun setup () { command { name = \"ping\" action { message . respond ( \"pong\" ) } } } Further functionality The commands framework is a deep, rich and feature-filled system that aims to support bot developers by making it as simple as possible to define commands that validate themselves and automatically parse their arguments. It also provides a set of classes that can be extended in order to further customize the behaviour of the commands system. The future of commands Parts of the commands framework are in the middle of being rewritten. That said, the commands system should be stable between versions - that is to say, we'll increment the version number before breaking it. We're hoping to expand upon this system in future, starting with a command dispatcher system that allows you to specify additional command dispatchers with their own prefixes and sets of commands, and switch out the argument parser used. This is a long way off, though, so we recommend keeping an eye on the GitHub repository if you're waiting for this. For more information on working with commands, please see the commands page .","title":"Reacting to commands"},{"location":"concepts/extensions/#polling-and-relaying","text":"For some bots, you'll need to work with external services. A common use-case is polling an external service and posting changes to a Discord channel, which you can do with Kotlin's Jobs. For this example, we'll write a quick extension that polls something every 30 seconds, and sends a message to a channel with updates. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 30 seconds in milliseconds private const val INTERVAL = 1000L * 30L // 10 seconds in milliseconds - use this if you need to wait for // guild members (for example) to be populated. private const val SETUP_DELAY = 1000L * 10L class CheckExtension ( bot : ExtensibleBot ) : Extension ( bot ) { override val name : String = \"check\" private var data : String = \"\" // ...or whatever private var job : Job ? = null override suspend fun setup () { // Iniital setup should always happen after the ReadyEvent. This // is because the ReadyEvent handler has some special logic. // You can read more about that on the events page. event < ReadyEvent > { action { delay ( SETUP_DELAY ) // Launch a job in Kord's coroutine scope job = bot . kord . launch { while ( true ) { delay ( INTERVAL ) val changed = doCheck () // Whatever it is if ( changed ) { getChannel (). createMessage ( \"Data updated: $data\" ) } } } } } } override suspend fun unload () { // This will be called if the extension is unloaded at any point, // we should stop the job if that happens. job ?. cancel () } } The important thing to note here is that we're launching the job in Kord's coroutine scope, which gives us a Job object we can keep track of. While extensions won't be automatically unloaded, extensions are able to load and unload each other, and all extensions are expected to support this behaviour. If you can't support unloading in your extension for some reason, remember to override unload() and throw an exception!","title":"Polling and relaying"},{"location":"concepts/extensions/#class-members","text":"The Extension class exposes several useful members, and some internal ones. Because we can't possibly know exactly what you need from this system, we don't hide the functional parts - but the below table will mark the things you probably don't need with a .","title":"Class Members"},{"location":"concepts/extensions/#properties","text":"Name Type Description name String The name of the extension, which is how it'll be referred to throughout the bot. eventHandlers MutableList <EventHandler> List of event handlers registered to this extension. commands MutableList <Command> List of commands registered to this extension. loaded Boolean Whether the extension is currently loaded - this is set automatically.","title":"Properties"},{"location":"concepts/extensions/#functions","text":"Name Description command Create a new command for this extension. event Create a new event handler for this extension. group Create a new grouped command for this extension (a command that can have subcommands). setup Override this and add all of your setup logic for the extension. unload Override this if you need to clean up when your extension is unloaded. doSetup Called by the bot when setting up the extension, firing events and handling extra setup tasks. doUnload Called by the bot when unloading the extension, firing events, unregistering event handlers and commands and handling extra cleanup.","title":"Functions"},{"location":"integrations/sentry/","text":"Sentry Sentry is a web-based tool used for keeping track of errors in your applications. Kord Extensions provides a first-party build-in integration for anyone that uses Sentry to keep track of errors in their production bots, with full support for breadcrumbs in your commands and event handlers so you can tell Sentry exactly what went wrong. Discord webhooks? Sentry does not support Discord webhooks out of the box - however, Discord does support Slack-format webhooks. As Slack requires current integrations to use OAuth, Sentry has hidden their legacy integration - but it can still be used. To find it, head to the settings for your project and append /plugins/slack/ to the URL - for example, https://sentry.io/settings/my-org/projects/bot/plugins/slack/ . The webhook URL should also have /slack appended, so it looks like this: https://discordapp.com/api/webhooks/{ID}/{TOKEN}/slack Setting up Kord Extensions ships with the Sentry library by default, but no logging integration - we recommend matching the version of your logging integration with the Sentry library shipped with Kord, but of course you can treat it just like any other transitive dependency. The ExtensibleBot object contains a sentry property referring to a SentryAdapter instance - to enable the Sentry integration, you'll need to set this object up using its init function. For example: 1 2 3 4 5 6 7 8 9 val bot = ExtensibleBot ( \"!\" , TOKEN ) if ( System . getenv (). getOrDefault ( \"SENTRY_DSN\" , null ) != null ) { bot . sentry . init { dsn = System . getenv ( \"SENTRY_DSN\" ) environment = environment = System . getenv (). getOrDefault ( \"ENVIRONMENT\" , \"production\" ) release = \"...\" // However you get your Sentry release info } } There's an alternative version of the init function that you can pass parameters to instead, but we highly recommend the use of the lambda-based function since it directly maps to Sentry's own init method. Adding context to errors Sentry's main method of collecting error context is to add breadcrumbs. Breadcrumbs essentially record the steps that were taken to reach your problem, including extra data that can provide additional context. Commands and event handlers both have built-in Sentry reporting, and include a mechanism for keeping track of breadcrumbs that you add as your command or event is processing. You can do this in one of two ways: Use the breadcrumb function on the CommandContext or EventContext object to add a breadcrumb Use the breadcrumbs mutable list on the CommandContext or EventContext object, and use the bot.sentry.createBreadcrumb function to create breadcrumbs to add to it - this is particularly useful if you need to pass the list around to different functions to collect breadcrumbs from them When an error occurs, the bot will create a Sentry scope configured with information about the command or event that caused the error, and it'll create an initial breadcrumb corresponding to the start of processing. It'll then take all the breadcrumbs you created, add them to the scope, and submit the scope directly to Sentry. There's nothing more that you need to do - you'll see the issue appear in Sentry with all of its breadcrumbs and associated context! For a list of supported breadcrumb types, please see the Sentry documentation . Collecting user feedback If an error occurs during command processing, and you have the Sentry extension enabled (which it is by default), the returned error message will contain a Sentry ID and information on how to submit a piece of user feedback. This includes a feedback command, which will be automatically registered by the Sentry extension. If you wish to disable this, pass false for the addSentryExtension constructor param for your ExtensibleBot instance, and both the Sentry ID in the error and the feedback command will be disabled. Manual usage You can, of course, make use of Sentry as per its documentation . However, bear in mind that both Kord and Kord Extensions are coroutine-based, and that means that a lot of the things you do will be asynchronous. Because of this, you'll want to collect breadcrumbs and other context yourself instead of creating a scope early - the best way of doing this is with a simple list of Breadcrumb objects. When an error happens, you can create the Sentry scope, add the breadcrumbs and other context, and submit it all at once. Failure to do this will result in issues, as Sentry uses a simple stack that it pushes and pops scopes onto without regard for any context - so you may end up adding breadcrumbs to the wrong scope, or submitting a scope from another part of the application too early if you don't watch out for this!","title":"Sentry"},{"location":"integrations/sentry/#sentry","text":"Sentry is a web-based tool used for keeping track of errors in your applications. Kord Extensions provides a first-party build-in integration for anyone that uses Sentry to keep track of errors in their production bots, with full support for breadcrumbs in your commands and event handlers so you can tell Sentry exactly what went wrong. Discord webhooks? Sentry does not support Discord webhooks out of the box - however, Discord does support Slack-format webhooks. As Slack requires current integrations to use OAuth, Sentry has hidden their legacy integration - but it can still be used. To find it, head to the settings for your project and append /plugins/slack/ to the URL - for example, https://sentry.io/settings/my-org/projects/bot/plugins/slack/ . The webhook URL should also have /slack appended, so it looks like this: https://discordapp.com/api/webhooks/{ID}/{TOKEN}/slack","title":"Sentry"},{"location":"integrations/sentry/#setting-up","text":"Kord Extensions ships with the Sentry library by default, but no logging integration - we recommend matching the version of your logging integration with the Sentry library shipped with Kord, but of course you can treat it just like any other transitive dependency. The ExtensibleBot object contains a sentry property referring to a SentryAdapter instance - to enable the Sentry integration, you'll need to set this object up using its init function. For example: 1 2 3 4 5 6 7 8 9 val bot = ExtensibleBot ( \"!\" , TOKEN ) if ( System . getenv (). getOrDefault ( \"SENTRY_DSN\" , null ) != null ) { bot . sentry . init { dsn = System . getenv ( \"SENTRY_DSN\" ) environment = environment = System . getenv (). getOrDefault ( \"ENVIRONMENT\" , \"production\" ) release = \"...\" // However you get your Sentry release info } } There's an alternative version of the init function that you can pass parameters to instead, but we highly recommend the use of the lambda-based function since it directly maps to Sentry's own init method.","title":"Setting up"},{"location":"integrations/sentry/#adding-context-to-errors","text":"Sentry's main method of collecting error context is to add breadcrumbs. Breadcrumbs essentially record the steps that were taken to reach your problem, including extra data that can provide additional context. Commands and event handlers both have built-in Sentry reporting, and include a mechanism for keeping track of breadcrumbs that you add as your command or event is processing. You can do this in one of two ways: Use the breadcrumb function on the CommandContext or EventContext object to add a breadcrumb Use the breadcrumbs mutable list on the CommandContext or EventContext object, and use the bot.sentry.createBreadcrumb function to create breadcrumbs to add to it - this is particularly useful if you need to pass the list around to different functions to collect breadcrumbs from them When an error occurs, the bot will create a Sentry scope configured with information about the command or event that caused the error, and it'll create an initial breadcrumb corresponding to the start of processing. It'll then take all the breadcrumbs you created, add them to the scope, and submit the scope directly to Sentry. There's nothing more that you need to do - you'll see the issue appear in Sentry with all of its breadcrumbs and associated context! For a list of supported breadcrumb types, please see the Sentry documentation .","title":"Adding context to errors"},{"location":"integrations/sentry/#collecting-user-feedback","text":"If an error occurs during command processing, and you have the Sentry extension enabled (which it is by default), the returned error message will contain a Sentry ID and information on how to submit a piece of user feedback. This includes a feedback command, which will be automatically registered by the Sentry extension. If you wish to disable this, pass false for the addSentryExtension constructor param for your ExtensibleBot instance, and both the Sentry ID in the error and the feedback command will be disabled.","title":"Collecting user feedback"},{"location":"integrations/sentry/#manual-usage","text":"You can, of course, make use of Sentry as per its documentation . However, bear in mind that both Kord and Kord Extensions are coroutine-based, and that means that a lot of the things you do will be asynchronous. Because of this, you'll want to collect breadcrumbs and other context yourself instead of creating a scope early - the best way of doing this is with a simple list of Breadcrumb objects. When an error happens, you can create the Sentry scope, add the breadcrumbs and other context, and submit it all at once. Failure to do this will result in issues, as Sentry uses a simple stack that it pushes and pops scopes onto without regard for any context - so you may end up adding breadcrumbs to the wrong scope, or submitting a scope from another part of the application too early if you don't watch out for this!","title":"Manual usage"}]}